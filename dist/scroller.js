!function(t){var I={};function g(n){if(I[n])return I[n].exports;var e=I[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,g),e.l=!0,e.exports}g.m=t,g.c=I,g.d=function(t,I,n){g.o(t,I)||Object.defineProperty(t,I,{enumerable:!0,get:n})},g.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},g.t=function(t,I){if(1&I&&(t=g(t)),8&I)return t;if(4&I&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(g.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&I&&"string"!=typeof t)for(var e in t)g.d(n,e,function(I){return t[I]}.bind(null,e));return n},g.n=function(t){var I=t&&t.__esModule?function(){return t.default}:function(){return t};return g.d(I,"a",I),I},g.o=function(t,I){return Object.prototype.hasOwnProperty.call(t,I)},g.p="",g(g.s=4)}([,,,function(module,exports){eval("/**\n * Copyright 2015 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (scope) {\n\n  // Number of items to instantiate beyond current view in the scroll direction.\n  var RUNWAY_ITEMS = 50;\n\n  // Number of items to instantiate beyond current view in the opposite direction.\n  var RUNWAY_ITEMS_OPPOSITE = 10;\n\n  // The number of pixels of additional length to allow scrolling to.\n  var SCROLL_RUNWAY = 5000;\n\n  // The animation interval (in ms) for fading in content from tombstones.\n  var ANIMATION_DURATION_MS = 200;\n\n  scope.InfiniteScrollerSource = function () {}\n\n  scope.InfiniteScrollerSource.prototype = {\n    /**\n     * Fetch more items from the data source. This should try to fetch at least\n     * count items but may fetch more as desired. Subsequent calls to fetch should\n     * fetch items following the last successful fetch.\n     * @param {number} count The minimum number of items to fetch for display.\n     * @return {Promise(Array<Object>)} Returns a promise which will be resolved\n     *     with an array of items.\n     */\n    fetch: function (count) {},\n\n    /**\n     * Create a tombstone element. All tombstone elements should be identical\n     * @return {Element} A tombstone element to be displayed when item data is not\n     *     yet available for the scrolled position.\n     */\n    createTombstone: function () {},\n\n    /**\n     * Render an item, re-using the provided item div if passed in.\n     * @param {Object} item The item description from the array returned by fetch.\n     * @param {?Element} element If provided, this is a previously displayed\n     *     element which should be recycled for the new item to display.\n     * @return {Element} The constructed element to be displayed in the scroller.\n     */\n    render: function (item, div) {},\n  };\n\n\n  /**\n   * Construct an infinite scroller.\n   * @param {Element} scroller The scrollable element to use as the infinite\n   *     scroll region.\n   * @param {InfiniteScrollerSource} source A provider of the content to be\n   *     displayed in the infinite scroll region.\n   */\n  scope.InfiniteScroller = function (scroller, source) {\n    this.anchorItem = {\n      index: 0,\n      offset: 0\n    };\n    this.firstAttachedItem_ = 0;\n    this.lastAttachedItem_ = 0;\n    this.anchorScrollTop = 0;\n    this.tombstoneSize_ = 0;\n    this.tombstoneWidth_ = 0;\n    this.tombstones_ = [];\n    this.scroller_ = scroller;\n    this.source_ = source;\n    this.items_ = [];\n    this.loadedItems_ = 0;\n    this.requestInProgress_ = false;\n    this.scroller_.addEventListener('scroll', this.onScroll_.bind(this));\n    window.addEventListener('resize', this.onResize_.bind(this));\n\n    // Create an element to force the scroller to allow scrolling to a certain\n    // point.\n    this.scrollRunway_ = document.createElement('div');\n    // Internet explorer seems to require some text in this div in order to\n    // ensure that it can be scrolled to.\n    this.scrollRunway_.textContent = ' ';\n    this.scrollRunwayEnd_ = 0;\n    this.scrollRunway_.style.position = 'absolute';\n    this.scrollRunway_.style.height = '1px';\n    this.scrollRunway_.style.width = '1px';\n    this.scrollRunway_.style.transition = 'transform 0.2s';\n    this.scroller_.appendChild(this.scrollRunway_);\n    this.onResize_();\n  }\n\n  scope.InfiniteScroller.prototype = {\n\n    /**\n     * Called when the browser window resizes to adapt to new scroller bounds and\n     * layout sizes of items within the scroller.\n     */\n    onResize_: function () {\n      // TODO: If we already have tombstones attached to the document, it would\n      // probably be more efficient to use one of them rather than create a new\n      // one to measure.\n      var tombstone = this.source_.createTombstone();\n      tombstone.style.position = 'absolute';\n      this.scroller_.appendChild(tombstone);\n      tombstone.classList.remove('invisible');\n      this.tombstoneSize_ = tombstone.offsetHeight;\n      this.tombstoneWidth_ = tombstone.offsetWidth;\n      this.scroller_.removeChild(tombstone);\n\n      // Reset the cached size of items in the scroller as they may no longer be\n      // correct after the item content undergoes layout.\n      for (var i = 0; i < this.items_.length; i++) {\n        this.items_[i].height = this.items_[i].width = 0;\n      }\n      this.onScroll_();\n    },\n\n    /**\n     * Called when the scroller scrolls. This determines the newly anchored item\n     * and offset and then updates the visible elements, requesting more items\n     * from the source if we've scrolled past the end of the currently available\n     * content.\n     */\n    onScroll_: function () {\n      var delta = this.scroller_.scrollTop - this.anchorScrollTop;\n      // Special case, if we get to very top, always scroll to top.\n      if (this.scroller_.scrollTop == 0) {\n        this.anchorItem = {\n          index: 0,\n          offset: 0\n        };\n      } else {\n        this.anchorItem = this.calculateAnchoredItem(this.anchorItem, delta);\n      }\n      this.anchorScrollTop = this.scroller_.scrollTop;\n      var lastScreenItem = this.calculateAnchoredItem(this.anchorItem, this.scroller_.offsetHeight);\n      if (delta < 0)\n        this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n      else\n        this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n    },\n\n    /**\n     * Calculates the item that should be anchored after scrolling by delta from\n     * the initial anchored item.\n     * @param {{index: number, offset: number}} initialAnchor The initial position\n     *     to scroll from before calculating the new anchor position.\n     * @param {number} delta The offset from the initial item to scroll by.\n     * @return {{index: number, offset: number}} Returns the new item and offset\n     *     scroll should be anchored to.\n     */\n    calculateAnchoredItem: function (initialAnchor, delta) {\n      if (delta == 0)\n        return initialAnchor;\n      delta += initialAnchor.offset;\n      var i = initialAnchor.index;\n      var tombstones = 0;\n      if (delta < 0) {\n        while (delta < 0 && i > 0 && this.items_[i - 1].height) {\n          delta += this.items_[i - 1].height;\n          i--;\n        }\n        tombstones = Math.max(-i, Math.ceil(Math.min(delta, 0) / this.tombstoneSize_));\n      } else {\n        while (delta > 0 && i < this.items_.length && this.items_[i].height && this.items_[i].height < delta) {\n          delta -= this.items_[i].height;\n          i++;\n        }\n        if (i >= this.items_.length || !this.items_[i].height)\n          tombstones = Math.floor(Math.max(delta, 0) / this.tombstoneSize_);\n      }\n      i += tombstones;\n      delta -= tombstones * this.tombstoneSize_;\n      return {\n        index: i,\n        offset: delta,\n      };\n    },\n\n    /**\n     * Sets the range of items which should be attached and attaches those items.\n     * @param {number} start The first item which should be attached.\n     * @param {number} end One past the last item which should be attached.\n     */\n    fill: function (start, end) {\n      this.firstAttachedItem_ = Math.max(0, start);\n      this.lastAttachedItem_ = end;\n      this.attachContent();\n    },\n\n    /**\n     * Creates or returns an existing tombstone ready to be reused.\n     * @return {Element} A tombstone element ready to be used.\n     */\n    getTombstone: function () {\n      var tombstone = this.tombstones_.pop();\n      if (tombstone) {\n        tombstone.classList.remove('invisible');\n        tombstone.style.opacity = 1;\n        tombstone.style.transform = '';\n        tombstone.style.transition = '';\n        return tombstone;\n      }\n      return this.source_.createTombstone();\n    },\n\n    /**\n     * Attaches content to the scroller and updates the scroll position if\n     * necessary.\n     */\n    attachContent: function () {\n      // Collect nodes which will no longer be rendered for reuse.\n      // TODO: Limit this based on the change in visible items rather than looping\n      // over all items.\n      var i;\n      var unusedNodes = [];\n      for (i = 0; i < this.items_.length; i++) {\n        // Skip the items which should be visible.\n        if (i == this.firstAttachedItem_) {\n          i = this.lastAttachedItem_ - 1;\n          continue;\n        }\n        if (this.items_[i].node) {\n          if (this.items_[i].node.classList.contains('tombstone')) {\n            this.tombstones_.push(this.items_[i].node);\n            this.tombstones_[this.tombstones_.length - 1].classList.add('invisible');\n          } else {\n            unusedNodes.push(this.items_[i].node);\n          }\n        }\n        this.items_[i].node = null;\n      }\n\n      var tombstoneAnimations = {};\n      // Create DOM nodes.\n      for (i = this.firstAttachedItem_; i < this.lastAttachedItem_; i++) {\n        while (this.items_.length <= i)\n          this.addItem_();\n        if (this.items_[i].node) {\n          // if it's a tombstone but we have data, replace it.\n          if (this.items_[i].node.classList.contains('tombstone') &&\n            this.items_[i].data) {\n            // TODO: Probably best to move items on top of tombstones and fade them in instead.\n            if (ANIMATION_DURATION_MS) {\n              this.items_[i].node.style.zIndex = 1;\n              tombstoneAnimations[i] = [this.items_[i].node, this.items_[i].top - this.anchorScrollTop];\n            } else {\n              this.items_[i].node.classList.add('invisible');\n              this.tombstones_.push(this.items_[i].node);\n            }\n            this.items_[i].node = null;\n          } else {\n            continue;\n          }\n        }\n        var node = this.items_[i].data ? this.source_.render(this.items_[i].data, unusedNodes.pop()) : this.getTombstone();\n        // Maybe don't do this if it's already attached?\n        node.style.position = 'absolute';\n        this.items_[i].top = -1;\n        this.scroller_.appendChild(node);\n        this.items_[i].node = node;\n      }\n\n      // Remove all unused nodes\n      while (unusedNodes.length) {\n        this.scroller_.removeChild(unusedNodes.pop());\n      }\n\n      // Get the height of all nodes which haven't been measured yet.\n      for (i = this.firstAttachedItem_; i < this.lastAttachedItem_; i++) {\n        // Only cache the height if we have the real contents, not a placeholder.\n        if (this.items_[i].data && !this.items_[i].height) {\n          this.items_[i].height = this.items_[i].node.offsetHeight;\n          this.items_[i].width = this.items_[i].node.offsetWidth;\n        }\n      }\n\n      // Fix scroll position in case we have realized the heights of elements\n      // that we didn't used to know.\n      // TODO: We should only need to do this when a height of an item becomes\n      // known above.\n      this.anchorScrollTop = 0;\n      for (i = 0; i < this.anchorItem.index; i++) {\n        this.anchorScrollTop += this.items_[i].height || this.tombstoneSize_;\n      }\n      this.anchorScrollTop += this.anchorItem.offset;\n\n      // Position all nodes.\n      var curPos = this.anchorScrollTop - this.anchorItem.offset;\n      i = this.anchorItem.index;\n      while (i > this.firstAttachedItem_) {\n        curPos -= this.items_[i - 1].height || this.tombstoneSize_;\n        i--;\n      }\n      while (i < this.firstAttachedItem_) {\n        curPos += this.items_[i].height || this.tombstoneSize_;\n        i++;\n      }\n      // Set up initial positions for animations.\n      for (var i in tombstoneAnimations) {\n        var anim = tombstoneAnimations[i];\n        this.items_[i].node.style.transform = 'translateY(' + (this.anchorScrollTop + anim[1]) + 'px) scale(' + (this.tombstoneWidth_ / this.items_[i].width) + ', ' + (this.tombstoneSize_ / this.items_[i].height) + ')';\n        // Call offsetTop on the nodes to be animated to force them to apply current transforms.\n        this.items_[i].node.offsetTop;\n        anim[0].offsetTop;\n        this.items_[i].node.style.transition = 'transform ' + ANIMATION_DURATION_MS + 'ms';\n      }\n      for (i = this.firstAttachedItem_; i < this.lastAttachedItem_; i++) {\n        var anim = tombstoneAnimations[i];\n        if (anim) {\n          anim[0].style.transition = 'transform ' + ANIMATION_DURATION_MS + 'ms, opacity ' + ANIMATION_DURATION_MS + 'ms';\n          anim[0].style.transform = 'translateY(' + curPos + 'px) scale(' + (this.items_[i].width / this.tombstoneWidth_) + ', ' + (this.items_[i].height / this.tombstoneSize_) + ')';\n          anim[0].style.opacity = 0;\n        }\n        if (curPos != this.items_[i].top) {\n          if (!anim)\n            this.items_[i].node.style.transition = '';\n          this.items_[i].node.style.transform = 'translateY(' + curPos + 'px)';\n        }\n        this.items_[i].top = curPos;\n        curPos += this.items_[i].height || this.tombstoneSize_;\n      }\n\n      this.scrollRunwayEnd_ = Math.max(this.scrollRunwayEnd_, curPos + SCROLL_RUNWAY)\n      this.scrollRunway_.style.transform = 'translate(0, ' + this.scrollRunwayEnd_ + 'px)';\n      this.scroller_.scrollTop = this.anchorScrollTop;\n\n      if (ANIMATION_DURATION_MS) {\n        // TODO: Should probably use transition end, but there are a lot of animations we could be listening to.\n        setTimeout(function () {\n          for (var i in tombstoneAnimations) {\n            var anim = tombstoneAnimations[i];\n            anim[0].classList.add('invisible');\n            this.tombstones_.push(anim[0]);\n            // Tombstone can be recycled now.\n          }\n        }.bind(this), ANIMATION_DURATION_MS)\n      }\n\n      this.maybeRequestContent();\n\n    },\n\n    /**\n     * Requests additional content if we don't have enough currently.\n     */\n    maybeRequestContent: function () {\n      // Don't issue another request if one is already in progress as we don't\n      // know where to start the next request yet.\n      if (this.requestInProgress_)\n        return;\n      var itemsNeeded = this.lastAttachedItem_ - this.loadedItems_;\n      if (itemsNeeded <= 0)\n        return;\n      this.requestInProgress_ = true;\n      this.source_.fetch(itemsNeeded).then(this.addContent.bind(this));\n    },\n\n    /**\n     * Adds an item to the items list.\n     */\n    addItem_: function () {\n      this.items_.push({\n        'data': null,\n        'node': null,\n        'height': 0,\n        'width': 0,\n        'top': 0,\n      })\n    },\n\n    /**\n     * Adds the given array of items to the items list and then calls\n     * attachContent to update the displayed content.\n     * @param {Array<Object>} items The array of items to be added to the infinite\n     *     scroller list.\n     */\n    addContent: function (items) {\n      this.requestInProgress_ = false;\n      for (var i = 0; i < items.length; i++) {\n        if (this.items_.length <= this.loadedItems_)\n          this.addItem_();\n        this.items_[this.loadedItems_++].data = items[i];\n      }\n      this.attachContent();\n    }\n  }\n})(self);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmZpbml0ZS1zY3JvbGwuanM/MjJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKHNjb3BlKSB7XG5cbiAgLy8gTnVtYmVyIG9mIGl0ZW1zIHRvIGluc3RhbnRpYXRlIGJleW9uZCBjdXJyZW50IHZpZXcgaW4gdGhlIHNjcm9sbCBkaXJlY3Rpb24uXG4gIHZhciBSVU5XQVlfSVRFTVMgPSA1MDtcblxuICAvLyBOdW1iZXIgb2YgaXRlbXMgdG8gaW5zdGFudGlhdGUgYmV5b25kIGN1cnJlbnQgdmlldyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICB2YXIgUlVOV0FZX0lURU1TX09QUE9TSVRFID0gMTA7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBwaXhlbHMgb2YgYWRkaXRpb25hbCBsZW5ndGggdG8gYWxsb3cgc2Nyb2xsaW5nIHRvLlxuICB2YXIgU0NST0xMX1JVTldBWSA9IDUwMDA7XG5cbiAgLy8gVGhlIGFuaW1hdGlvbiBpbnRlcnZhbCAoaW4gbXMpIGZvciBmYWRpbmcgaW4gY29udGVudCBmcm9tIHRvbWJzdG9uZXMuXG4gIHZhciBBTklNQVRJT05fRFVSQVRJT05fTVMgPSAyMDA7XG5cbiAgc2NvcGUuSW5maW5pdGVTY3JvbGxlclNvdXJjZSA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgc2NvcGUuSW5maW5pdGVTY3JvbGxlclNvdXJjZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbW9yZSBpdGVtcyBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBzaG91bGQgdHJ5IHRvIGZldGNoIGF0IGxlYXN0XG4gICAgICogY291bnQgaXRlbXMgYnV0IG1heSBmZXRjaCBtb3JlIGFzIGRlc2lyZWQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gZmV0Y2ggc2hvdWxkXG4gICAgICogZmV0Y2ggaXRlbXMgZm9sbG93aW5nIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgZmV0Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBpdGVtcyB0byBmZXRjaCBmb3IgZGlzcGxheS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKEFycmF5PE9iamVjdD4pfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkXG4gICAgICogICAgIHdpdGggYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAgICovXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIChjb3VudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0b21ic3RvbmUgZWxlbWVudC4gQWxsIHRvbWJzdG9uZSBlbGVtZW50cyBzaG91bGQgYmUgaWRlbnRpY2FsXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gQSB0b21ic3RvbmUgZWxlbWVudCB0byBiZSBkaXNwbGF5ZWQgd2hlbiBpdGVtIGRhdGEgaXMgbm90XG4gICAgICogICAgIHlldCBhdmFpbGFibGUgZm9yIHRoZSBzY3JvbGxlZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGVUb21ic3RvbmU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFuIGl0ZW0sIHJlLXVzaW5nIHRoZSBwcm92aWRlZCBpdGVtIGRpdiBpZiBwYXNzZWQgaW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gZGVzY3JpcHRpb24gZnJvbSB0aGUgYXJyYXkgcmV0dXJuZWQgYnkgZmV0Y2guXG4gICAgICogQHBhcmFtIHs/RWxlbWVudH0gZWxlbWVudCBJZiBwcm92aWRlZCwgdGhpcyBpcyBhIHByZXZpb3VzbHkgZGlzcGxheWVkXG4gICAgICogICAgIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHJlY3ljbGVkIGZvciB0aGUgbmV3IGl0ZW0gdG8gZGlzcGxheS5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgY29uc3RydWN0ZWQgZWxlbWVudCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHNjcm9sbGVyLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKGl0ZW0sIGRpdikge30sXG4gIH07XG5cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGluZmluaXRlIHNjcm9sbGVyLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNjcm9sbGVyIFRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgdG8gdXNlIGFzIHRoZSBpbmZpbml0ZVxuICAgKiAgICAgc2Nyb2xsIHJlZ2lvbi5cbiAgICogQHBhcmFtIHtJbmZpbml0ZVNjcm9sbGVyU291cmNlfSBzb3VyY2UgQSBwcm92aWRlciBvZiB0aGUgY29udGVudCB0byBiZVxuICAgKiAgICAgZGlzcGxheWVkIGluIHRoZSBpbmZpbml0ZSBzY3JvbGwgcmVnaW9uLlxuICAgKi9cbiAgc2NvcGUuSW5maW5pdGVTY3JvbGxlciA9IGZ1bmN0aW9uIChzY3JvbGxlciwgc291cmNlKSB7XG4gICAgdGhpcy5hbmNob3JJdGVtID0ge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9O1xuICAgIHRoaXMuZmlyc3RBdHRhY2hlZEl0ZW1fID0gMDtcbiAgICB0aGlzLmxhc3RBdHRhY2hlZEl0ZW1fID0gMDtcbiAgICB0aGlzLmFuY2hvclNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy50b21ic3RvbmVTaXplXyA9IDA7XG4gICAgdGhpcy50b21ic3RvbmVXaWR0aF8gPSAwO1xuICAgIHRoaXMudG9tYnN0b25lc18gPSBbXTtcbiAgICB0aGlzLnNjcm9sbGVyXyA9IHNjcm9sbGVyO1xuICAgIHRoaXMuc291cmNlXyA9IHNvdXJjZTtcbiAgICB0aGlzLml0ZW1zXyA9IFtdO1xuICAgIHRoaXMubG9hZGVkSXRlbXNfID0gMDtcbiAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzXyA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsZXJfLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGxfLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplXy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIENyZWF0ZSBhbiBlbGVtZW50IHRvIGZvcmNlIHRoZSBzY3JvbGxlciB0byBhbGxvdyBzY3JvbGxpbmcgdG8gYSBjZXJ0YWluXG4gICAgLy8gcG9pbnQuXG4gICAgdGhpcy5zY3JvbGxSdW53YXlfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gSW50ZXJuZXQgZXhwbG9yZXIgc2VlbXMgdG8gcmVxdWlyZSBzb21lIHRleHQgaW4gdGhpcyBkaXYgaW4gb3JkZXIgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBpdCBjYW4gYmUgc2Nyb2xsZWQgdG8uXG4gICAgdGhpcy5zY3JvbGxSdW53YXlfLnRleHRDb250ZW50ID0gJyAnO1xuICAgIHRoaXMuc2Nyb2xsUnVud2F5RW5kXyA9IDA7XG4gICAgdGhpcy5zY3JvbGxSdW53YXlfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLnNjcm9sbFJ1bndheV8uc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gICAgdGhpcy5zY3JvbGxSdW53YXlfLnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgdGhpcy5zY3JvbGxSdW53YXlfLnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtIDAuMnMnO1xuICAgIHRoaXMuc2Nyb2xsZXJfLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsUnVud2F5Xyk7XG4gICAgdGhpcy5vblJlc2l6ZV8oKTtcbiAgfVxuXG4gIHNjb3BlLkluZmluaXRlU2Nyb2xsZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IHJlc2l6ZXMgdG8gYWRhcHQgdG8gbmV3IHNjcm9sbGVyIGJvdW5kcyBhbmRcbiAgICAgKiBsYXlvdXQgc2l6ZXMgb2YgaXRlbXMgd2l0aGluIHRoZSBzY3JvbGxlci5cbiAgICAgKi9cbiAgICBvblJlc2l6ZV86IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IElmIHdlIGFscmVhZHkgaGF2ZSB0b21ic3RvbmVzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgaXQgd291bGRcbiAgICAgIC8vIHByb2JhYmx5IGJlIG1vcmUgZWZmaWNpZW50IHRvIHVzZSBvbmUgb2YgdGhlbSByYXRoZXIgdGhhbiBjcmVhdGUgYSBuZXdcbiAgICAgIC8vIG9uZSB0byBtZWFzdXJlLlxuICAgICAgdmFyIHRvbWJzdG9uZSA9IHRoaXMuc291cmNlXy5jcmVhdGVUb21ic3RvbmUoKTtcbiAgICAgIHRvbWJzdG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLnNjcm9sbGVyXy5hcHBlbmRDaGlsZCh0b21ic3RvbmUpO1xuICAgICAgdG9tYnN0b25lLmNsYXNzTGlzdC5yZW1vdmUoJ2ludmlzaWJsZScpO1xuICAgICAgdGhpcy50b21ic3RvbmVTaXplXyA9IHRvbWJzdG9uZS5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLnRvbWJzdG9uZVdpZHRoXyA9IHRvbWJzdG9uZS5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuc2Nyb2xsZXJfLnJlbW92ZUNoaWxkKHRvbWJzdG9uZSk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBjYWNoZWQgc2l6ZSBvZiBpdGVtcyBpbiB0aGUgc2Nyb2xsZXIgYXMgdGhleSBtYXkgbm8gbG9uZ2VyIGJlXG4gICAgICAvLyBjb3JyZWN0IGFmdGVyIHRoZSBpdGVtIGNvbnRlbnQgdW5kZXJnb2VzIGxheW91dC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5pdGVtc19baV0uaGVpZ2h0ID0gdGhpcy5pdGVtc19baV0ud2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5vblNjcm9sbF8oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHNjcm9sbGVyIHNjcm9sbHMuIFRoaXMgZGV0ZXJtaW5lcyB0aGUgbmV3bHkgYW5jaG9yZWQgaXRlbVxuICAgICAqIGFuZCBvZmZzZXQgYW5kIHRoZW4gdXBkYXRlcyB0aGUgdmlzaWJsZSBlbGVtZW50cywgcmVxdWVzdGluZyBtb3JlIGl0ZW1zXG4gICAgICogZnJvbSB0aGUgc291cmNlIGlmIHdlJ3ZlIHNjcm9sbGVkIHBhc3QgdGhlIGVuZCBvZiB0aGUgY3VycmVudGx5IGF2YWlsYWJsZVxuICAgICAqIGNvbnRlbnQuXG4gICAgICovXG4gICAgb25TY3JvbGxfOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLnNjcm9sbGVyXy5zY3JvbGxUb3AgLSB0aGlzLmFuY2hvclNjcm9sbFRvcDtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSwgaWYgd2UgZ2V0IHRvIHZlcnkgdG9wLCBhbHdheXMgc2Nyb2xsIHRvIHRvcC5cbiAgICAgIGlmICh0aGlzLnNjcm9sbGVyXy5zY3JvbGxUb3AgPT0gMCkge1xuICAgICAgICB0aGlzLmFuY2hvckl0ZW0gPSB7XG4gICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFuY2hvckl0ZW0gPSB0aGlzLmNhbGN1bGF0ZUFuY2hvcmVkSXRlbSh0aGlzLmFuY2hvckl0ZW0sIGRlbHRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxlcl8uc2Nyb2xsVG9wO1xuICAgICAgdmFyIGxhc3RTY3JlZW5JdGVtID0gdGhpcy5jYWxjdWxhdGVBbmNob3JlZEl0ZW0odGhpcy5hbmNob3JJdGVtLCB0aGlzLnNjcm9sbGVyXy5vZmZzZXRIZWlnaHQpO1xuICAgICAgaWYgKGRlbHRhIDwgMClcbiAgICAgICAgdGhpcy5maWxsKHRoaXMuYW5jaG9ySXRlbS5pbmRleCAtIFJVTldBWV9JVEVNUywgbGFzdFNjcmVlbkl0ZW0uaW5kZXggKyBSVU5XQVlfSVRFTVNfT1BQT1NJVEUpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmZpbGwodGhpcy5hbmNob3JJdGVtLmluZGV4IC0gUlVOV0FZX0lURU1TX09QUE9TSVRFLCBsYXN0U2NyZWVuSXRlbS5pbmRleCArIFJVTldBWV9JVEVNUyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGl0ZW0gdGhhdCBzaG91bGQgYmUgYW5jaG9yZWQgYWZ0ZXIgc2Nyb2xsaW5nIGJ5IGRlbHRhIGZyb21cbiAgICAgKiB0aGUgaW5pdGlhbCBhbmNob3JlZCBpdGVtLlxuICAgICAqIEBwYXJhbSB7e2luZGV4OiBudW1iZXIsIG9mZnNldDogbnVtYmVyfX0gaW5pdGlhbEFuY2hvciBUaGUgaW5pdGlhbCBwb3NpdGlvblxuICAgICAqICAgICB0byBzY3JvbGwgZnJvbSBiZWZvcmUgY2FsY3VsYXRpbmcgdGhlIG5ldyBhbmNob3IgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFRoZSBvZmZzZXQgZnJvbSB0aGUgaW5pdGlhbCBpdGVtIHRvIHNjcm9sbCBieS5cbiAgICAgKiBAcmV0dXJuIHt7aW5kZXg6IG51bWJlciwgb2Zmc2V0OiBudW1iZXJ9fSBSZXR1cm5zIHRoZSBuZXcgaXRlbSBhbmQgb2Zmc2V0XG4gICAgICogICAgIHNjcm9sbCBzaG91bGQgYmUgYW5jaG9yZWQgdG8uXG4gICAgICovXG4gICAgY2FsY3VsYXRlQW5jaG9yZWRJdGVtOiBmdW5jdGlvbiAoaW5pdGlhbEFuY2hvciwgZGVsdGEpIHtcbiAgICAgIGlmIChkZWx0YSA9PSAwKVxuICAgICAgICByZXR1cm4gaW5pdGlhbEFuY2hvcjtcbiAgICAgIGRlbHRhICs9IGluaXRpYWxBbmNob3Iub2Zmc2V0O1xuICAgICAgdmFyIGkgPSBpbml0aWFsQW5jaG9yLmluZGV4O1xuICAgICAgdmFyIHRvbWJzdG9uZXMgPSAwO1xuICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICB3aGlsZSAoZGVsdGEgPCAwICYmIGkgPiAwICYmIHRoaXMuaXRlbXNfW2kgLSAxXS5oZWlnaHQpIHtcbiAgICAgICAgICBkZWx0YSArPSB0aGlzLml0ZW1zX1tpIC0gMV0uaGVpZ2h0O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICB0b21ic3RvbmVzID0gTWF0aC5tYXgoLWksIE1hdGguY2VpbChNYXRoLm1pbihkZWx0YSwgMCkgLyB0aGlzLnRvbWJzdG9uZVNpemVfKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoZGVsdGEgPiAwICYmIGkgPCB0aGlzLml0ZW1zXy5sZW5ndGggJiYgdGhpcy5pdGVtc19baV0uaGVpZ2h0ICYmIHRoaXMuaXRlbXNfW2ldLmhlaWdodCA8IGRlbHRhKSB7XG4gICAgICAgICAgZGVsdGEgLT0gdGhpcy5pdGVtc19baV0uaGVpZ2h0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSB0aGlzLml0ZW1zXy5sZW5ndGggfHwgIXRoaXMuaXRlbXNfW2ldLmhlaWdodClcbiAgICAgICAgICB0b21ic3RvbmVzID0gTWF0aC5mbG9vcihNYXRoLm1heChkZWx0YSwgMCkgLyB0aGlzLnRvbWJzdG9uZVNpemVfKTtcbiAgICAgIH1cbiAgICAgIGkgKz0gdG9tYnN0b25lcztcbiAgICAgIGRlbHRhIC09IHRvbWJzdG9uZXMgKiB0aGlzLnRvbWJzdG9uZVNpemVfO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIG9mZnNldDogZGVsdGEsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByYW5nZSBvZiBpdGVtcyB3aGljaCBzaG91bGQgYmUgYXR0YWNoZWQgYW5kIGF0dGFjaGVzIHRob3NlIGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgZmlyc3QgaXRlbSB3aGljaCBzaG91bGQgYmUgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBPbmUgcGFzdCB0aGUgbGFzdCBpdGVtIHdoaWNoIHNob3VsZCBiZSBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBmaWxsOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5maXJzdEF0dGFjaGVkSXRlbV8gPSBNYXRoLm1heCgwLCBzdGFydCk7XG4gICAgICB0aGlzLmxhc3RBdHRhY2hlZEl0ZW1fID0gZW5kO1xuICAgICAgdGhpcy5hdHRhY2hDb250ZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgcmV0dXJucyBhbiBleGlzdGluZyB0b21ic3RvbmUgcmVhZHkgdG8gYmUgcmV1c2VkLlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IEEgdG9tYnN0b25lIGVsZW1lbnQgcmVhZHkgdG8gYmUgdXNlZC5cbiAgICAgKi9cbiAgICBnZXRUb21ic3RvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b21ic3RvbmUgPSB0aGlzLnRvbWJzdG9uZXNfLnBvcCgpO1xuICAgICAgaWYgKHRvbWJzdG9uZSkge1xuICAgICAgICB0b21ic3RvbmUuY2xhc3NMaXN0LnJlbW92ZSgnaW52aXNpYmxlJyk7XG4gICAgICAgIHRvbWJzdG9uZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgdG9tYnN0b25lLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB0b21ic3RvbmUuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICByZXR1cm4gdG9tYnN0b25lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5jcmVhdGVUb21ic3RvbmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgY29udGVudCB0byB0aGUgc2Nyb2xsZXIgYW5kIHVwZGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZlxuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBhdHRhY2hDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb2xsZWN0IG5vZGVzIHdoaWNoIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbmRlcmVkIGZvciByZXVzZS5cbiAgICAgIC8vIFRPRE86IExpbWl0IHRoaXMgYmFzZWQgb24gdGhlIGNoYW5nZSBpbiB2aXNpYmxlIGl0ZW1zIHJhdGhlciB0aGFuIGxvb3BpbmdcbiAgICAgIC8vIG92ZXIgYWxsIGl0ZW1zLlxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdW51c2VkTm9kZXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLml0ZW1zXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTa2lwIHRoZSBpdGVtcyB3aGljaCBzaG91bGQgYmUgdmlzaWJsZS5cbiAgICAgICAgaWYgKGkgPT0gdGhpcy5maXJzdEF0dGFjaGVkSXRlbV8pIHtcbiAgICAgICAgICBpID0gdGhpcy5sYXN0QXR0YWNoZWRJdGVtXyAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlbXNfW2ldLm5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pdGVtc19baV0ubm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RvbWJzdG9uZScpKSB7XG4gICAgICAgICAgICB0aGlzLnRvbWJzdG9uZXNfLnB1c2godGhpcy5pdGVtc19baV0ubm9kZSk7XG4gICAgICAgICAgICB0aGlzLnRvbWJzdG9uZXNfW3RoaXMudG9tYnN0b25lc18ubGVuZ3RoIC0gMV0uY2xhc3NMaXN0LmFkZCgnaW52aXNpYmxlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVudXNlZE5vZGVzLnB1c2godGhpcy5pdGVtc19baV0ubm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXNfW2ldLm5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9tYnN0b25lQW5pbWF0aW9ucyA9IHt9O1xuICAgICAgLy8gQ3JlYXRlIERPTSBub2Rlcy5cbiAgICAgIGZvciAoaSA9IHRoaXMuZmlyc3RBdHRhY2hlZEl0ZW1fOyBpIDwgdGhpcy5sYXN0QXR0YWNoZWRJdGVtXzsgaSsrKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLml0ZW1zXy5sZW5ndGggPD0gaSlcbiAgICAgICAgICB0aGlzLmFkZEl0ZW1fKCk7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zX1tpXS5ub2RlKSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBhIHRvbWJzdG9uZSBidXQgd2UgaGF2ZSBkYXRhLCByZXBsYWNlIGl0LlxuICAgICAgICAgIGlmICh0aGlzLml0ZW1zX1tpXS5ub2RlLmNsYXNzTGlzdC5jb250YWlucygndG9tYnN0b25lJykgJiZcbiAgICAgICAgICAgIHRoaXMuaXRlbXNfW2ldLmRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFByb2JhYmx5IGJlc3QgdG8gbW92ZSBpdGVtcyBvbiB0b3Agb2YgdG9tYnN0b25lcyBhbmQgZmFkZSB0aGVtIGluIGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoQU5JTUFUSU9OX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICAgIHRoaXMuaXRlbXNfW2ldLm5vZGUuc3R5bGUuekluZGV4ID0gMTtcbiAgICAgICAgICAgICAgdG9tYnN0b25lQW5pbWF0aW9uc1tpXSA9IFt0aGlzLml0ZW1zX1tpXS5ub2RlLCB0aGlzLml0ZW1zX1tpXS50b3AgLSB0aGlzLmFuY2hvclNjcm9sbFRvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2ludmlzaWJsZScpO1xuICAgICAgICAgICAgICB0aGlzLnRvbWJzdG9uZXNfLnB1c2godGhpcy5pdGVtc19baV0ubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pdGVtc19baV0uZGF0YSA/IHRoaXMuc291cmNlXy5yZW5kZXIodGhpcy5pdGVtc19baV0uZGF0YSwgdW51c2VkTm9kZXMucG9wKCkpIDogdGhpcy5nZXRUb21ic3RvbmUoKTtcbiAgICAgICAgLy8gTWF5YmUgZG9uJ3QgZG8gdGhpcyBpZiBpdCdzIGFscmVhZHkgYXR0YWNoZWQ/XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLml0ZW1zX1tpXS50b3AgPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxlcl8uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHRoaXMuaXRlbXNfW2ldLm5vZGUgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIHVudXNlZCBub2Rlc1xuICAgICAgd2hpbGUgKHVudXNlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnNjcm9sbGVyXy5yZW1vdmVDaGlsZCh1bnVzZWROb2Rlcy5wb3AoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgaGVpZ2h0IG9mIGFsbCBub2RlcyB3aGljaCBoYXZlbid0IGJlZW4gbWVhc3VyZWQgeWV0LlxuICAgICAgZm9yIChpID0gdGhpcy5maXJzdEF0dGFjaGVkSXRlbV87IGkgPCB0aGlzLmxhc3RBdHRhY2hlZEl0ZW1fOyBpKyspIHtcbiAgICAgICAgLy8gT25seSBjYWNoZSB0aGUgaGVpZ2h0IGlmIHdlIGhhdmUgdGhlIHJlYWwgY29udGVudHMsIG5vdCBhIHBsYWNlaG9sZGVyLlxuICAgICAgICBpZiAodGhpcy5pdGVtc19baV0uZGF0YSAmJiAhdGhpcy5pdGVtc19baV0uaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5pdGVtc19baV0uaGVpZ2h0ID0gdGhpcy5pdGVtc19baV0ubm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgdGhpcy5pdGVtc19baV0ud2lkdGggPSB0aGlzLml0ZW1zX1tpXS5ub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpeCBzY3JvbGwgcG9zaXRpb24gaW4gY2FzZSB3ZSBoYXZlIHJlYWxpemVkIHRoZSBoZWlnaHRzIG9mIGVsZW1lbnRzXG4gICAgICAvLyB0aGF0IHdlIGRpZG4ndCB1c2VkIHRvIGtub3cuXG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgb25seSBuZWVkIHRvIGRvIHRoaXMgd2hlbiBhIGhlaWdodCBvZiBhbiBpdGVtIGJlY29tZXNcbiAgICAgIC8vIGtub3duIGFib3ZlLlxuICAgICAgdGhpcy5hbmNob3JTY3JvbGxUb3AgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYW5jaG9ySXRlbS5pbmRleDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsVG9wICs9IHRoaXMuaXRlbXNfW2ldLmhlaWdodCB8fCB0aGlzLnRvbWJzdG9uZVNpemVfO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmNob3JTY3JvbGxUb3AgKz0gdGhpcy5hbmNob3JJdGVtLm9mZnNldDtcblxuICAgICAgLy8gUG9zaXRpb24gYWxsIG5vZGVzLlxuICAgICAgdmFyIGN1clBvcyA9IHRoaXMuYW5jaG9yU2Nyb2xsVG9wIC0gdGhpcy5hbmNob3JJdGVtLm9mZnNldDtcbiAgICAgIGkgPSB0aGlzLmFuY2hvckl0ZW0uaW5kZXg7XG4gICAgICB3aGlsZSAoaSA+IHRoaXMuZmlyc3RBdHRhY2hlZEl0ZW1fKSB7XG4gICAgICAgIGN1clBvcyAtPSB0aGlzLml0ZW1zX1tpIC0gMV0uaGVpZ2h0IHx8IHRoaXMudG9tYnN0b25lU2l6ZV87XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpIDwgdGhpcy5maXJzdEF0dGFjaGVkSXRlbV8pIHtcbiAgICAgICAgY3VyUG9zICs9IHRoaXMuaXRlbXNfW2ldLmhlaWdodCB8fCB0aGlzLnRvbWJzdG9uZVNpemVfO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICAvLyBTZXQgdXAgaW5pdGlhbCBwb3NpdGlvbnMgZm9yIGFuaW1hdGlvbnMuXG4gICAgICBmb3IgKHZhciBpIGluIHRvbWJzdG9uZUFuaW1hdGlvbnMpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB0b21ic3RvbmVBbmltYXRpb25zW2ldO1xuICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKCcgKyAodGhpcy5hbmNob3JTY3JvbGxUb3AgKyBhbmltWzFdKSArICdweCkgc2NhbGUoJyArICh0aGlzLnRvbWJzdG9uZVdpZHRoXyAvIHRoaXMuaXRlbXNfW2ldLndpZHRoKSArICcsICcgKyAodGhpcy50b21ic3RvbmVTaXplXyAvIHRoaXMuaXRlbXNfW2ldLmhlaWdodCkgKyAnKSc7XG4gICAgICAgIC8vIENhbGwgb2Zmc2V0VG9wIG9uIHRoZSBub2RlcyB0byBiZSBhbmltYXRlZCB0byBmb3JjZSB0aGVtIHRvIGFwcGx5IGN1cnJlbnQgdHJhbnNmb3Jtcy5cbiAgICAgICAgdGhpcy5pdGVtc19baV0ubm9kZS5vZmZzZXRUb3A7XG4gICAgICAgIGFuaW1bMF0ub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtICcgKyBBTklNQVRJT05fRFVSQVRJT05fTVMgKyAnbXMnO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gdGhpcy5maXJzdEF0dGFjaGVkSXRlbV87IGkgPCB0aGlzLmxhc3RBdHRhY2hlZEl0ZW1fOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW0gPSB0b21ic3RvbmVBbmltYXRpb25zW2ldO1xuICAgICAgICBpZiAoYW5pbSkge1xuICAgICAgICAgIGFuaW1bMF0uc3R5bGUudHJhbnNpdGlvbiA9ICd0cmFuc2Zvcm0gJyArIEFOSU1BVElPTl9EVVJBVElPTl9NUyArICdtcywgb3BhY2l0eSAnICsgQU5JTUFUSU9OX0RVUkFUSU9OX01TICsgJ21zJztcbiAgICAgICAgICBhbmltWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKCcgKyBjdXJQb3MgKyAncHgpIHNjYWxlKCcgKyAodGhpcy5pdGVtc19baV0ud2lkdGggLyB0aGlzLnRvbWJzdG9uZVdpZHRoXykgKyAnLCAnICsgKHRoaXMuaXRlbXNfW2ldLmhlaWdodCAvIHRoaXMudG9tYnN0b25lU2l6ZV8pICsgJyknO1xuICAgICAgICAgIGFuaW1bMF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1clBvcyAhPSB0aGlzLml0ZW1zX1tpXS50b3ApIHtcbiAgICAgICAgICBpZiAoIWFuaW0pXG4gICAgICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICB0aGlzLml0ZW1zX1tpXS5ub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKCcgKyBjdXJQb3MgKyAncHgpJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zX1tpXS50b3AgPSBjdXJQb3M7XG4gICAgICAgIGN1clBvcyArPSB0aGlzLml0ZW1zX1tpXS5oZWlnaHQgfHwgdGhpcy50b21ic3RvbmVTaXplXztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxSdW53YXlFbmRfID0gTWF0aC5tYXgodGhpcy5zY3JvbGxSdW53YXlFbmRfLCBjdXJQb3MgKyBTQ1JPTExfUlVOV0FZKVxuICAgICAgdGhpcy5zY3JvbGxSdW53YXlfLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgJyArIHRoaXMuc2Nyb2xsUnVud2F5RW5kXyArICdweCknO1xuICAgICAgdGhpcy5zY3JvbGxlcl8uc2Nyb2xsVG9wID0gdGhpcy5hbmNob3JTY3JvbGxUb3A7XG5cbiAgICAgIGlmIChBTklNQVRJT05fRFVSQVRJT05fTVMpIHtcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uIGVuZCwgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBhbmltYXRpb25zIHdlIGNvdWxkIGJlIGxpc3RlbmluZyB0by5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0b21ic3RvbmVBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYW5pbSA9IHRvbWJzdG9uZUFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICBhbmltWzBdLmNsYXNzTGlzdC5hZGQoJ2ludmlzaWJsZScpO1xuICAgICAgICAgICAgdGhpcy50b21ic3RvbmVzXy5wdXNoKGFuaW1bMF0pO1xuICAgICAgICAgICAgLy8gVG9tYnN0b25lIGNhbiBiZSByZWN5Y2xlZCBub3cuXG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyksIEFOSU1BVElPTl9EVVJBVElPTl9NUylcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXliZVJlcXVlc3RDb250ZW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYWRkaXRpb25hbCBjb250ZW50IGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIGN1cnJlbnRseS5cbiAgICAgKi9cbiAgICBtYXliZVJlcXVlc3RDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCBpc3N1ZSBhbm90aGVyIHJlcXVlc3QgaWYgb25lIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYXMgd2UgZG9uJ3RcbiAgICAgIC8vIGtub3cgd2hlcmUgdG8gc3RhcnQgdGhlIG5leHQgcmVxdWVzdCB5ZXQuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SW5Qcm9ncmVzc18pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBpdGVtc05lZWRlZCA9IHRoaXMubGFzdEF0dGFjaGVkSXRlbV8gLSB0aGlzLmxvYWRlZEl0ZW1zXztcbiAgICAgIGlmIChpdGVtc05lZWRlZCA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzXyA9IHRydWU7XG4gICAgICB0aGlzLnNvdXJjZV8uZmV0Y2goaXRlbXNOZWVkZWQpLnRoZW4odGhpcy5hZGRDb250ZW50LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGl0ZW1zIGxpc3QuXG4gICAgICovXG4gICAgYWRkSXRlbV86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXRlbXNfLnB1c2goe1xuICAgICAgICAnZGF0YSc6IG51bGwsXG4gICAgICAgICdub2RlJzogbnVsbCxcbiAgICAgICAgJ2hlaWdodCc6IDAsXG4gICAgICAgICd3aWR0aCc6IDAsXG4gICAgICAgICd0b3AnOiAwLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgaXRlbXMgdG8gdGhlIGl0ZW1zIGxpc3QgYW5kIHRoZW4gY2FsbHNcbiAgICAgKiBhdHRhY2hDb250ZW50IHRvIHVwZGF0ZSB0aGUgZGlzcGxheWVkIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBpdGVtcyBUaGUgYXJyYXkgb2YgaXRlbXMgdG8gYmUgYWRkZWQgdG8gdGhlIGluZmluaXRlXG4gICAgICogICAgIHNjcm9sbGVyIGxpc3QuXG4gICAgICovXG4gICAgYWRkQ29udGVudDogZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzXyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5pdGVtc18ubGVuZ3RoIDw9IHRoaXMubG9hZGVkSXRlbXNfKVxuICAgICAgICAgIHRoaXMuYWRkSXRlbV8oKTtcbiAgICAgICAgdGhpcy5pdGVtc19bdGhpcy5sb2FkZWRJdGVtc18rK10uZGF0YSA9IGl0ZW1zW2ldO1xuICAgICAgfVxuICAgICAgdGhpcy5hdHRhY2hDb250ZW50KCk7XG4gICAgfVxuICB9XG59KShzZWxmKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _infinite_scroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var _infinite_scroll__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_infinite_scroll__WEBPACK_IMPORTED_MODULE_0__);\n\nvar INIT_TIME = new Date().getTime()\nfunction getItem(id) {\n  function pickRandom(a) {\n    return a[Math.floor(Math.random() * a.length)];\n  }\n\n  return new Promise(function (resolve) {\n    \n    var item = new Array(5).fill('').map((e,index) => {\n      return {\n        id: id * 5 + index + 1,\n        choosed: false,\n      }\n    })\n    resolve(item)\n  });\n}\n\nclass ContentSource {\n  constructor () {\n    this.tombstone_ = document.querySelector(\"#templates > .seat-row.tombstone\");\n    this.seatTemplate_ = document.querySelector(\"#templates > .seat-row:not(.tombstone)\");\n    this.nextItem_ = 0\n  }\n  fetch (count) {\n    count =100 * 5;\n    return new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        var items = []\n        for (var i = 0; i < Math.abs(count); i++) {\n          items[i] = getItem(this.nextItem_++);\n        }\n        resolve(Promise.all(items));\n      }.bind(this), 300 /* 1s请求延迟 */ );\n    }.bind(this))\n  }\n  createTombstone () {\n    return this.tombstone_.cloneNode(true)\n  }\n\n  render (row, div) {\n    console.log(row)\n    div = div || this.seatTemplate_.cloneNode(true)\n    const lis = div.querySelectorAll('li')\n    row.forEach((item, index) => {\n      lis[index].textContent = item.id\n      lis[index].dataset.id = item.id\n      lis[index].dataset.choosed = item.choosed ? '1' : '0'\n      if (item.choosed) {\n        lis[index].classList.add('choosed')\n      } else {\n        lis[index].classList.remove('choosed')\n      }\n    })\n    \n    return div\n  }\n}\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  window.scroller =\n    new InfiniteScroller(\n      document.querySelector('.main'),\n      new ContentSource()\n    );\n\n\n   document.querySelector('.main').addEventListener('click', (event) => {\n     if (event.target.className.indexOf('seat') <= -1) {\n       return\n     }\n     const ele = event.target\n     if ('0' === ele.dataset.choosed) {\n       ele.dataset.choosed = '1'\n       ele.classList.add('choosed')\n       return\n     }\n     ele.dataset.choosed = '0'\n     ele.classList.remove('choosed')\n   })\n\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zY3JvbGxlci5qcz9lZmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7fSBmcm9tIFwiLi9pbmZpbml0ZS1zY3JvbGxcIlxudmFyIElOSVRfVElNRSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG5mdW5jdGlvbiBnZXRJdGVtKGlkKSB7XG4gIGZ1bmN0aW9uIHBpY2tSYW5kb20oYSkge1xuICAgIHJldHVybiBhW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGEubGVuZ3RoKV07XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBcbiAgICB2YXIgaXRlbSA9IG5ldyBBcnJheSg1KS5maWxsKCcnKS5tYXAoKGUsaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCAqIDUgKyBpbmRleCArIDEsXG4gICAgICAgIGNob29zZWQ6IGZhbHNlLFxuICAgICAgfVxuICAgIH0pXG4gICAgcmVzb2x2ZShpdGVtKVxuICB9KTtcbn1cblxuY2xhc3MgQ29udGVudFNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnRvbWJzdG9uZV8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RlbXBsYXRlcyA+IC5zZWF0LXJvdy50b21ic3RvbmVcIik7XG4gICAgdGhpcy5zZWF0VGVtcGxhdGVfID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZW1wbGF0ZXMgPiAuc2VhdC1yb3c6bm90KC50b21ic3RvbmUpXCIpO1xuICAgIHRoaXMubmV4dEl0ZW1fID0gMFxuICB9XG4gIGZldGNoIChjb3VudCkge1xuICAgIGNvdW50ID0xMDAgKiA1O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLmFicyhjb3VudCk7IGkrKykge1xuICAgICAgICAgIGl0ZW1zW2ldID0gZ2V0SXRlbSh0aGlzLm5leHRJdGVtXysrKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKFByb21pc2UuYWxsKGl0ZW1zKSk7XG4gICAgICB9LmJpbmQodGhpcyksIDMwMCAvKiAxc+ivt+axguW7tui/nyAqLyApO1xuICAgIH0uYmluZCh0aGlzKSlcbiAgfVxuICBjcmVhdGVUb21ic3RvbmUgKCkge1xuICAgIHJldHVybiB0aGlzLnRvbWJzdG9uZV8uY2xvbmVOb2RlKHRydWUpXG4gIH1cblxuICByZW5kZXIgKHJvdywgZGl2KSB7XG4gICAgY29uc29sZS5sb2cocm93KVxuICAgIGRpdiA9IGRpdiB8fCB0aGlzLnNlYXRUZW1wbGF0ZV8uY2xvbmVOb2RlKHRydWUpXG4gICAgY29uc3QgbGlzID0gZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJylcbiAgICByb3cuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGxpc1tpbmRleF0udGV4dENvbnRlbnQgPSBpdGVtLmlkXG4gICAgICBsaXNbaW5kZXhdLmRhdGFzZXQuaWQgPSBpdGVtLmlkXG4gICAgICBsaXNbaW5kZXhdLmRhdGFzZXQuY2hvb3NlZCA9IGl0ZW0uY2hvb3NlZCA/ICcxJyA6ICcwJ1xuICAgICAgaWYgKGl0ZW0uY2hvb3NlZCkge1xuICAgICAgICBsaXNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2Nob29zZWQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKCdjaG9vc2VkJylcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBkaXZcbiAgfVxufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICB3aW5kb3cuc2Nyb2xsZXIgPVxuICAgIG5ldyBJbmZpbml0ZVNjcm9sbGVyKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4nKSxcbiAgICAgIG5ldyBDb250ZW50U291cmNlKClcbiAgICApO1xuXG5cbiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgaWYgKGV2ZW50LnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignc2VhdCcpIDw9IC0xKSB7XG4gICAgICAgcmV0dXJuXG4gICAgIH1cbiAgICAgY29uc3QgZWxlID0gZXZlbnQudGFyZ2V0XG4gICAgIGlmICgnMCcgPT09IGVsZS5kYXRhc2V0LmNob29zZWQpIHtcbiAgICAgICBlbGUuZGF0YXNldC5jaG9vc2VkID0gJzEnXG4gICAgICAgZWxlLmNsYXNzTGlzdC5hZGQoJ2Nob29zZWQnKVxuICAgICAgIHJldHVyblxuICAgICB9XG4gICAgIGVsZS5kYXRhc2V0LmNob29zZWQgPSAnMCdcbiAgICAgZWxlLmNsYXNzTGlzdC5yZW1vdmUoJ2Nob29zZWQnKVxuICAgfSlcblxufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")}]);